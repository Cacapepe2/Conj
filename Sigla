import pandas as pd
import os
import pickle
from datetime import datetime, timedelta
import re

def carregar_dados_science_com_cache(estados_selecionados=['RJ', 'ES', 'MG'], usar_cache=True, cache_expira_dias=7):
    """
    Carrega dados do Science com sistema de cache por estado
    
    Args:
        estados_selecionados: Lista com estados desejados ['RJ', 'ES', 'MG']
        usar_cache: Se deve usar cache (True/False)
        cache_expira_dias: Dias para expirar o cache
    
    Returns:
        DataFrame concatenado dos estados selecionados
    """
    
    # Definir caminhos base por estado
    caminhos_por_estado = {
        'RJ': {
            '2G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_2G_RJ.xlsx",
            '3G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_3G_RJ.xlsx", 
            '4G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_4G_RJ.xlsx",
            '5G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_5G_RJ.xlsx",
            'IoT': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_IoT_RJ.xlsx"
        },
        'ES': {
            '2G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_2G_ES.xlsx",
            '3G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_3G_ES.xlsx",
            '4G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_4G_ES.xlsx",
            '5G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_5G_ES.xlsx",
            'IoT': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_IoT_ES.xlsx"
        },
        'MG': {
            '2G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_2G_MG.xlsx",
            '3G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_3G_MG.xlsx",
            '4G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_4G_MG.xlsx",
            '5G': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_5G_MG.xlsx",
            'IoT': r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_IoT_MG.xlsx"
        }
    }
    
    # Caso voc√™ tenha arquivos √∫nicos, use os caminhos originais
    caminhos_unicos = [
        r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_2G.xlsx",
        r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_3G.xlsx",
        r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_4G.xlsx",
        r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_5G.xlsx",
        r"C:\Users\40417519\Telefonica\Engenharia de RF LESTE (RJ ES BA SE) - Science\Base_dados\Science_IoT.xlsx"
    ]
    
    # Criar diret√≥rio de cache se n√£o existir
    cache_dir = "cache_science"
    if not os.path.exists(cache_dir):
        os.makedirs(cache_dir)
    
    dataframes = []
    
    # Verificar se existe separa√ß√£o por estado ou usar arquivo √∫nico
    usar_arquivo_unico = True
    for estado in estados_selecionados:
        for tecnologia in ['2G', '3G', '4G', '5G', 'IoT']:
            if estado in caminhos_por_estado and os.path.exists(caminhos_por_estado[estado][tecnologia]):
                usar_arquivo_unico = False
                break
        if not usar_arquivo_unico:
            break
    
    if usar_arquivo_unico:
        print("Usando arquivos √∫nicos do Science...")
        # Carregar todos os arquivos e filtrar por estado depois
        cache_file = os.path.join(cache_dir, f"science_completo.pkl")
        
        # Verificar cache
        if usar_cache and os.path.exists(cache_file):
            # Verificar se cache n√£o expirou
            cache_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
            if datetime.now() - cache_time < timedelta(days=cache_expira_dias):
                print("Carregando dados do cache...")
                with open(cache_file, 'rb') as f:
                    df_total = pickle.load(f)
                # Filtrar apenas os estados selecionados
                if 'UF' in df_total.columns:
                    df_total = df_total[df_total['UF'].isin(estados_selecionados)]
                return df_total
        
        print("Cache expirado ou n√£o existe. Carregando arquivos originais...")
        # Carregar arquivos originais
        for caminho in caminhos_unicos:
            if os.path.exists(caminho):
                try:
                    print(f"Carregando {os.path.basename(caminho)}...")
                    df_temp = pd.read_excel(caminho, usecols=["SIG_SITE", "SIG_ERB", "NUM_LATITUDE_DECIMAL", "NUM_LONGITUDE_DECIMAL"])
                    dataframes.append(df_temp)
                except Exception as e:
                    print(f"Erro ao carregar {caminho}: {e}")
        
        # Concatenar todos os dataframes
        if dataframes:
            df_total = pd.concat(dataframes, ignore_index=True)
            
            # Salvar no cache
            if usar_cache:
                print("Salvando no cache...")
                with open(cache_file, 'wb') as f:
                    pickle.dump(df_total, f)
            
            # Filtrar estados se a coluna UF existir
            if 'UF' in df_total.columns:
                df_total = df_total[df_total['UF'].isin(estados_selecionados)]
                
            return df_total
    else:
        # Usar arquivos separados por estado
        print("Usando arquivos separados por estado...")
        for estado in estados_selecionados:
            cache_file = os.path.join(cache_dir, f"science_{estado}.pkl")
            
            # Verificar cache para este estado
            if usar_cache and os.path.exists(cache_file):
                cache_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
                if datetime.now() - cache_time < timedelta(days=cache_expira_dias):
                    print(f"Carregando {estado} do cache...")
                    with open(cache_file, 'rb') as f:
                        df_estado = pickle.load(f)
                    dataframes.append(df_estado)
                    continue
            
            # Carregar arquivos para este estado
            print(f"Carregando arquivos do {estado}...")
            df_estado_temp = []
            for tecnologia in ['2G', '3G', '4G', '5G', 'IoT']:
                caminho = caminhos_por_estado[estado][tecnologia]
                if os.path.exists(caminho):
                    try:
                        df_temp = pd.read_excel(caminho, usecols=["SIG_SITE", "SIG_ERB", "NUM_LATITUDE_DECIMAL", "NUM_LONGITUDE_DECIMAL"])
                        df_estado_temp.append(df_temp)
                    except Exception as e:
                        print(f"Erro ao carregar {caminho}: {e}")
            
            # Concatenar arquivos do estado
            if df_estado_temp:
                df_estado = pd.concat(df_estado_temp, ignore_index=True)
                dataframes.append(df_estado)
                
                # Salvar cache do estado
                if usar_cache:
                    with open(cache_file, 'wb') as f:
                        pickle.dump(df_estado, f)
        
        # Concatenar todos os estados
        if dataframes:
            df_total = pd.concat(dataframes, ignore_index=True)
            return df_total
    
    return pd.DataFrame()  # Retorna dataframe vazio se nada foi carregado

def gerar_sigla_site(nome_completo, uf, siglas_existentes):
    """
    Gera sigla do site seguindo as regras especificadas
    
    Args:
        nome_completo: Nome completo do site (ex: "Nova Igua√ßu - Vila Laje Lagoinha")
        uf: Unidade Federativa (ex: "RJ")
        siglas_existentes: Set com siglas j√° existentes
    
    Returns:
        String com a sigla gerada (ex: "RJVLL")
    """
    
    # Separar munic√≠pio da localiza√ß√£o ap√≥s o h√≠fen
    partes = nome_completo.split(' - ')
    if len(partes) < 2:
        # Se n√£o tem h√≠fen, usar o nome completo
        municipio = ""
        localizacao = nome_completo.strip()
    else:
        municipio = partes[0].strip()
        localizacao = partes[1].strip()
    
    # Remover acentos e caracteres especiais da localiza√ß√£o
    localizacao_limpa = re.sub(r'[^\w\s]', '', localizacao)
    localizacao_limpa = (localizacao_limpa.replace('√£', 'a').replace('√°', 'a').replace('√†', 'a')
                        .replace('√©', 'e').replace('√™', 'e').replace('√≠', 'i').replace('√≥', 'o')
                        .replace('√¥', 'o').replace('√∫', 'u').replace('√ß', 'c').replace('√±', 'n'))
    
    # Separar palavras da localiza√ß√£o
    palavras = [palavra for palavra in localizacao_limpa.split() if len(palavra) > 0]
    
    # Fun√ß√£o auxiliar para gerar combina√ß√µes
    def tentar_sigla(combinacao):
        sigla_teste = uf.upper() + combinacao.upper()
        return sigla_teste if sigla_teste not in siglas_existentes else None
    
    # Estrat√©gias de gera√ß√£o baseadas no n√∫mero de palavras
    if len(palavras) == 1:
        # Uma palavra: usar as 3 primeiras letras
        palavra = palavras[0]
        sigla = tentar_sigla(palavra[:3])
        if sigla:
            return sigla
            
    elif len(palavras) == 2:
        # Duas palavras: 
        # 1¬™ tentativa: 2 letras da primeira + 1 da segunda
        sigla = tentar_sigla(palavras[0][:2] + palavras[1][:1])
        if sigla:
            return sigla
        
        # 2¬™ tentativa: 1 letra da primeira + 2 da segunda
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:2])
        if sigla:
            return sigla
            
    elif len(palavras) == 3:
        # Tr√™s palavras:
        # 1¬™ tentativa: 1 letra de cada palavra
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:1] + palavras[2][:1])
        if sigla:
            return sigla
        
        # 2¬™ tentativa: 2 da primeira + 1 da segunda
        sigla = tentar_sigla(palavras[0][:2] + palavras[1][:1])
        if sigla:
            return sigla
            
        # 3¬™ tentativa: 1 da primeira + 2 da segunda
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:2])
        if sigla:
            return sigla
            
    elif len(palavras) >= 4:
        # Quatro ou mais palavras:
        # 1¬™ tentativa: 1 letra das 3 primeiras
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:1] + palavras[2][:1])
        if sigla:
            return sigla
            
        # 2¬™ tentativa: 2 da primeira + 1 da segunda
        sigla = tentar_sigla(palavras[0][:2] + palavras[1][:1])
        if sigla:
            return sigla
            
        # 3¬™ tentativa: 1 da primeira + 1 da segunda + 1 da terceira
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:1] + palavras[2][:1])
        if sigla:
            return sigla
            
        # 4¬™ tentativa: usar a 4¬™ palavra
        sigla = tentar_sigla(palavras[0][:1] + palavras[1][:1] + palavras[3][:1])
        if sigla:
            return sigla
    
    # Se todas as tentativas falharam, usar munic√≠pio como √∫ltimo recurso
    if municipio:
        municipio_limpo = re.sub(r'[^\w\s]', '', municipio)
        municipio_limpo = (municipio_limpo.replace('√£', 'a').replace('√°', 'a').replace('√†', 'a')
                          .replace('√©', 'e').replace('√™', 'e').replace('√≠', 'i').replace('√≥', 'o')
                          .replace('√¥', 'o').replace('√∫', 'u').replace('√ß', 'c').replace('√±', 'n'))
        
        palavras_municipio = municipio_limpo.split()
        
        # Tentar combina√ß√µes com munic√≠pio
        for i in range(1, 4):  # 1, 2 ou 3 letras do munic√≠pio
            if palavras_municipio and len(palavras_municipio[0]) >= i:
                resto_letras = 3 - i
                if palavras and len(palavras[0]) >= resto_letras:
                    sigla = tentar_sigla(palavras_municipio[0][:i] + palavras[0][:resto_letras])
                    if sigla:
                        return sigla
    
    # √öltimo recurso: usar n√∫meros sequenciais
    for num in range(1, 1000):
        if len(palavras) > 0:
            sigla = tentar_sigla(palavras[0][:2] + str(num))
            if sigla:
                return sigla
        else:
            sigla = tentar_sigla(uf[:2] + str(num))
            if sigla:
                return sigla
    
    # Se tudo falhar, usar timestamp
    import time
    timestamp = str(int(time.time()))[-3:]
    return uf.upper() + timestamp

def processar_siglas_sites(df_generica, df_science, nome_coluna_site='NOME_SITE', nome_coluna_uf='UF'):
    """
    Processa e adiciona siglas aos sites do dataframe gen√©rica
    
    Args:
        df_generica: DataFrame com dados gen√©ricos incluindo nomes de sites
        df_science: DataFrame do Science com siglas existentes
        nome_coluna_site: Nome da coluna que cont√©m os nomes dos sites
        nome_coluna_uf: Nome da coluna que cont√©m a UF
        
    Returns:
        DataFrame gen√©rica com nova coluna 'Nome_Master' (sigla do site)
    """
    
    # Extrair siglas existentes do Science (assumindo que est√° na coluna SIG_SITE)
    siglas_existentes = set()
    if 'SIG_SITE' in df_science.columns:
        siglas_existentes = set(df_science['SIG_SITE'].dropna().unique())
        print(f"   Encontradas {len(siglas_existentes)} siglas existentes no Science")
    
    # Verificar se as colunas necess√°rias existem no df_generica
    if nome_coluna_site not in df_generica.columns:
        print(f"‚ùå Erro: Coluna '{nome_coluna_site}' n√£o encontrada no DataFrame gen√©rica")
        print(f"   Colunas dispon√≠veis: {list(df_generica.columns)}")
        return df_generica
        
    if nome_coluna_uf not in df_generica.columns:
        print(f"‚ùå Erro: Coluna '{nome_coluna_uf}' n√£o encontrada no DataFrame gen√©rica")
        print(f"   Colunas dispon√≠veis: {list(df_generica.columns)}")
        return df_generica
    
    # Criar nova coluna Nome_Master para as siglas (substituir se j√° existir)
    df_result = df_generica.copy()
    if 'Nome_Master' in df_result.columns:
        print("   ‚ö†Ô∏è Coluna 'Nome_Master' j√° existe, ser√° substitu√≠da")
    df_result['Nome_Master'] = ''
    
    # Processar cada linha
    print("   üîÑ Gerando siglas para os sites...")
    total_sites = len(df_result)
    
    for index, row in df_result.iterrows():
        # Obter dados da linha atual
        nome_site = str(row[nome_coluna_site]) if pd.notna(row[nome_coluna_site]) else ''
        uf = str(row[nome_coluna_uf]) if pd.notna(row[nome_coluna_uf]) else ''
        
        # Pular se dados essenciais est√£o vazios
        if not nome_site or not uf:
            print(f"   ‚ö†Ô∏è Linha {index + 1}: Dados incompletos (Nome: '{nome_site}', UF: '{uf}')")
            continue
        
        # Gerar sigla √∫nica
        sigla = gerar_sigla_site(nome_site, uf, siglas_existentes)
        
        # Adicionar a nova sigla ao conjunto de existentes
        siglas_existentes.add(sigla)
        
        # Adicionar ao DataFrame
        df_result.loc[index, 'Nome_Master'] = sigla
        
        # Log do progresso a cada 100 sites
        if (index + 1) % 100 == 0:
            porcentagem = ((index + 1) / total_sites) * 100
            print(f"   üìä Processados {index + 1}/{total_sites} sites ({porcentagem:.1f}%)")
    
    # Estat√≠sticas finais
    siglas_geradas = len(df_result[df_result['Nome_Master'] != ''])
    print(f"   ‚úÖ Processamento conclu√≠do!")
    print(f"   üìä {siglas_geradas}/{total_sites} siglas geradas com sucesso")
    
    return df_result

def salvar_de_volta_para_excel(df_final, nome_arquivo_original, nome_planilha="a"):
    """
    Salva o DataFrame de volta para o arquivo Excel original
    
    Args:
        df_final: DataFrame com as siglas processadas
        nome_arquivo_original: Nome do arquivo Excel original
        nome_planilha: Nome da planilha (sheet) a ser atualizada
        
    Returns:
        bool: True se salvou com sucesso, False caso contr√°rio
    """
    try:
        print(f"   üìù Salvando de volta em '{nome_arquivo_original}', planilha '{nome_planilha}'...")
        
        # Verificar se o arquivo original existe
        if not os.path.exists(nome_arquivo_original):
            print(f"   ‚ùå Arquivo '{nome_arquivo_original}' n√£o encontrado!")
            return False
        
        # Criar backup do arquivo original
        backup_nome = nome_arquivo_original.replace('.xlsx', '_backup.xlsx')
        if not os.path.exists(backup_nome):
            import shutil
            shutil.copy2(nome_arquivo_original, backup_nome)
            print(f"   üíæ Backup criado: '{backup_nome}'")
        
        # Ler todas as planilhas do arquivo original
        with pd.ExcelFile(nome_arquivo_original) as arquivo_excel:
            todas_planilhas = {}
            
            # Carregar todas as planilhas existentes
            for sheet_name in arquivo_excel.sheet_names:
                if sheet_name == nome_planilha:
                    # Usar o DataFrame processado para a planilha alvo
                    todas_planilhas[sheet_name] = df_final
                    print(f"   üîÑ Planilha '{sheet_name}' ser√° atualizada com {len(df_final)} registros")
                else:
                    # Manter outras planilhas inalteradas
                    todas_planilhas[sheet_name] = pd.read_excel(arquivo_excel, sheet_name=sheet_name)
                    print(f"   üìã Planilha '{sheet_name}' mantida inalterada")
        
        # Salvar todas as planilhas de volta
        with pd.ExcelWriter(nome_arquivo_original, engine='openpyxl') as writer:
            for sheet_name, df_sheet in todas_planilhas.items():
                df_sheet.to_excel(writer, sheet_name=sheet_name, index=False)
        
        print(f"   ‚úÖ Arquivo atualizado com sucesso!")
        return True
        
    except Exception as e:
        print(f"   ‚ùå Erro ao salvar arquivo: {e}")
        
        # Tentar salvar com nome alternativo
        try:
            nome_alternativo = nome_arquivo_original.replace('.xlsx', '_com_siglas.xlsx')
            df_final.to_excel(nome_alternativo, index=False)
            print(f"   üíæ Dados salvos em arquivo alternativo: '{nome_alternativo}'")
            return True
        except Exception as e2:
            print(f"   ‚ùå Erro ao salvar arquivo alternativo: {e2}")
            return False

def escolher_estados():
    """
    Interface interativa para o usu√°rio escolher quais estados carregar
    
    Returns:
        Lista com estados selecionados
    """
    print("\n=== SELE√á√ÉO DE ESTADOS ===")
    print("Escolha quais estados voc√™ deseja carregar:")
    print("1 - Apenas Rio de Janeiro (RJ)")
    print("2 - Apenas Esp√≠rito Santo (ES)")
    print("3 - Apenas Minas Gerais (MG)")
    print("4 - Rio de Janeiro + Esp√≠rito Santo (RJ + ES)")
    print("5 - Rio de Janeiro + Minas Gerais (RJ + MG)")
    print("6 - Esp√≠rito Santo + Minas Gerais (ES + MG)")
    print("7 - Todos os estados (RJ + ES + MG)")
    print("8 - Personalizado (escolher individualmente)")
    
    opcoes_estados = {
        '1': ['RJ'],
        '2': ['ES'],
        '3': ['MG'],
        '4': ['RJ', 'ES'],
        '5': ['RJ', 'MG'],
        '6': ['ES', 'MG'],
        '7': ['RJ', 'ES', 'MG'],
    }
    
    while True:
        try:
            opcao = input("\nDigite sua op√ß√£o (1-8): ").strip()
            
            if opcao in opcoes_estados:
                estados = opcoes_estados[opcao]
                print(f"Estados selecionados: {', '.join(estados)}")
                return estados
                
            elif opcao == '8':
                # Op√ß√£o personalizada
                print("\n=== SELE√á√ÉO PERSONALIZADA ===")
                estados_disponiveis = ['RJ', 'ES', 'MG']
                estados_escolhidos = []
                
                for estado in estados_disponiveis:
                    while True:
                        escolha = input(f"Incluir {estado}? (s/n): ").strip().lower()
                        if escolha in ['s', 'sim', 'y', 'yes']:
                            estados_escolhidos.append(estado)
                            break
                        elif escolha in ['n', 'n√£o', 'nao', 'no']:
                            break
                        else:
                            print("Por favor, digite 's' para sim ou 'n' para n√£o.")
                
                if estados_escolhidos:
                    print(f"Estados selecionados: {', '.join(estados_escolhidos)}")
                    return estados_escolhidos
                else:
                    print("Nenhum estado selecionado! Escolha pelo menos um.")
                    continue
                    
            else:
                print("Op√ß√£o inv√°lida! Digite um n√∫mero de 1 a 8.")
                
        except KeyboardInterrupt:
            print("\n\nOpera√ß√£o cancelada pelo usu√°rio.")
            exit()
        except Exception as e:
            print(f"Erro na entrada: {e}")

def escolher_configuracao_cache():
    """
    Permite ao usu√°rio configurar o cache
    
    Returns:
        Tuple (usar_cache, dias_expiracao)
    """
    print("\n=== CONFIGURA√á√ÉO DO CACHE ===")
    print("O cache acelera execu√ß√µes futuras salvando os dados j√° carregados.")
    
    while True:
        try:
            usar = input("Usar cache? (s/n) [padr√£o: s]: ").strip().lower()
            if usar == '' or usar in ['s', 'sim', 'y', 'yes']:
                usar_cache = True
                break
            elif usar in ['n', 'n√£o', 'nao', 'no']:
                usar_cache = False
                return usar_cache, 0
            else:
                print("Digite 's' para sim ou 'n' para n√£o.")
    
    if usar_cache:
        while True:
            try:
                dias = input("Dias para expirar cache [padr√£o: 7]: ").strip()
                if dias == '':
                    dias_expiracao = 7
                    break
                else:
                    dias_expiracao = int(dias)
                    if dias_expiracao > 0:
                        break
                    else:
                        print("Digite um n√∫mero maior que zero.")
            except ValueError:
                print("Digite um n√∫mero v√°lido.")
        
        print(f"Cache configurado: {dias_expiracao} dias de expira√ß√£o")
        return usar_cache, dias_expiracao
    
    return usar_cache, 0

# Exemplo de uso:
if __name__ == "__main__":
    print("=== MACRO AUTOMA√á√ÉO SOI ===")
    
    # 1. Carregar dados gen√©ricos
    print("\n1. Carregando dados gen√©ricos...")
    try:
        generica = pd.read_excel("Macro Automa√ß√£o SOI", sheet_name="a")
        print(f"   ‚úì Dados gen√©ricos carregados: {len(generica)} registros")
    except Exception as e:
        print(f"   ‚úó Erro ao carregar dados gen√©ricos: {e}")
        exit()
    
    # 2. Usu√°rio escolhe estados
    estados_selecionados = escolher_estados()
    
    # 3. Usu√°rio configura cache
    usar_cache, dias_cache = escolher_configuracao_cache()
    
    # 4. Carregar dados do Science com as configura√ß√µes escolhidas
    print(f"\n4. Carregando dados do Science para os estados: {', '.join(estados_selecionados)}")
    tempo_inicio = datetime.now()
    
    df_science = carregar_dados_science_com_cache(
        estados_selecionados=estados_selecionados,
        usar_cache=usar_cache,
        cache_expira_dias=dias_cache
    )
    
    tempo_fim = datetime.now()
    tempo_decorrido = tempo_fim - tempo_inicio
    print(f"   ‚è±Ô∏è Tempo de carregamento: {tempo_decorrido.total_seconds():.2f} segundos")
    
    if df_science.empty:
        print("   ‚úó Erro: Nenhum dado do Science foi carregado!")
        exit()
    else:
        print(f"   ‚úì Dados do Science carregados: {len(df_science)} registros")
    
    # 5. Processar siglas
    print("\n5. Processando siglas dos sites...")
    df_final = processar_siglas_sites(generica, df_science)
    
    # 6. Salvar resultado
    print("\n6. Salvando resultado...")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    estados_str = "_".join(estados_selecionados)
    nome_arquivo_saida = f"Macro_Automacao_SOI_{estados_str}_{timestamp}.xlsx"
    
    try:
        df_final.to_excel(nome_arquivo_saida, index=False)
        print(f"   ‚úì Arquivo salvo como: {nome_arquivo_saida}")
    except Exception as e:
        print(f"   ‚úó Erro ao salvar arquivo: {e}")
    
    # 7. Mostrar estat√≠sticas
    print("\n7. Estat√≠sticas finais:")
    if 'SIGLA_SITE' in df_final.columns:
        print(f"   üìä Total de sites processados: {len(df_final)}")
        print(f"   üìä Siglas √∫nicas geradas: {len(df_final['SIGLA_SITE'].unique())}")
        if 'UF' in df_final.columns:
            print(f"   üìä Distribui√ß√£o por estado:")
            for uf in sorted(df_final['UF'].unique()):
                count = len(df_final[df_final['UF'] == uf])
                porcentagem = (count / len(df_final)) * 100
                print(f"      {uf}: {count} sites ({porcentagem:.1f}%)")
    
    print(f"\n   ‚è±Ô∏è Tempo total de processamento: {(datetime.now() - tempo_inicio).total_seconds():.2f} segundos")
    print("\n=== ‚úÖ PROCESSAMENTO CONCLU√çDO ===")
    
    # 8. Op√ß√µes p√≥s-processamento
    print("\n=== OP√á√ïES ADICIONAIS ===")
    while True:
        print("\nO que voc√™ gostaria de fazer?")
        print("1 - Executar novamente com outros estados")
        print("2 - Limpar cache")
        print("3 - Ver informa√ß√µes do cache")
        print("4 - Sair")
        
        opcao = input("\nDigite sua op√ß√£o (1-4): ").strip()
        
        if opcao == '1':
            # Executar novamente
            estados_selecionados = escolher_estados()
            usar_cache, dias_cache = escolher_configuracao_cache()
            # ... repetir o processo
            break
        elif opcao == '2':
            # Limpar cache
            import shutil
            cache_dir = "cache_science"
            if os.path.exists(cache_dir):
                shutil.rmtree(cache_dir)
                print("‚úì Cache limpo com sucesso!")
            else:
                print("‚ÑπÔ∏è Nenhum cache encontrado.")
        elif opcao == '3':
            # Ver informa√ß√µes do cache
            cache_dir = "cache_science"
            if os.path.exists(cache_dir):
                print(f"\nüìÅ Arquivos de cache em '{cache_dir}':")
                for arquivo in os.listdir(cache_dir):
                    caminho = os.path.join(cache_dir, arquivo)
                    tamanho = os.path.getsize(caminho) / 1024 / 1024  # MB
                    data_mod = datetime.fromtimestamp(os.path.getmtime(caminho))
                    print(f"   {arquivo}: {tamanho:.2f} MB (modificado: {data_mod.strftime('%d/%m/%Y %H:%M')})")
            else:
                print("‚ÑπÔ∏è Nenhum cache encontrado.")
        elif opcao == '4':
            break
        else:
            print("Op√ß√£o inv√°lida!")
