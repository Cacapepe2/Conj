import pandas as pd

# exemplo do seu dicionário (mantenha/expanda conforme necessário)
rru_rules = {
    3: {
        "700": (3, 3),
        "1800/2100": (2, 3),
        "1800/2100/2600": (2, 3),
        "2600": (2, 3), 
    },
    2: {
        "700": (2, 2),
        "1800/2100": (1, 2),
        "1800/2100/2600": (1, 2),
        "2600": (1, 2),
    },
    1: {
        "700": (1, 1),
        "1800/2100": (1, 1),
        "1800/2100/2600": (1, 1),
        "2600": (1, 1),
    }
}

def calcular_rrus(row):
    # valida setores
    try:
        setores = int(row.get("Setor"))
    except Exception:
        return 0

    rules = rru_rules.get(setores)
    if not rules:
        return 0

    # tratar valores vazios
    if pd.isna(row.get("FINAL Frequência 4G")) or str(row.get("FINAL Frequência 4G")).strip() == "":
        return 0

    freq_str = str(row.get("FINAL Frequência 4G"))
    mimo_str = "" if pd.isna(row.get("FINAL MIMO 4G")) else str(row.get("FINAL MIMO 4G"))

    # tokens normalizados
    freq_tokens = set(t.strip() for t in freq_str.split("/") if t and t.strip().lower() != "nan")
    mimo_tokens = set(t.strip() for t in mimo_str.split("/") if t and t.strip().lower() != "nan")

    # prepara regras como (set_tokens, rru_sem, rru_com) e ordena por tamanho decrescente
    rule_items = []
    for key, (rru_sem, rru_com) in rules.items():
        tokens = set(t.strip() for t in str(key).split("/") if t)
        rule_items.append((tokens, rru_sem, rru_com))
    rule_items.sort(key=lambda x: -len(x[0]))  # combinações maiores primeiro

    total = 0
    # aplica regras greedy
    for token_set, rru_sem, rru_com in rule_items:
        if token_set and token_set.issubset(freq_tokens):
            # usa valor com MIMO só se todos os tokens da regra estiverem no MIMO
            if token_set.issubset(mimo_tokens):
                total += rru_com
            else:
                total += rru_sem
            # evita dupla contagem
            freq_tokens -= token_set

    # opcional: tentar casar quaisquer tokens restantes com regras de 1 token
    if freq_tokens:
        for freq in list(freq_tokens):
            for token_set, rru_sem, rru_com in rule_items:
                if len(token_set) == 1 and freq in token_set:
                    if token_set.issubset(mimo_tokens):
                        total += rru_com
                    else:
                        total += rru_sem
                    freq_tokens.remove(freq)
                    break
            # se não casar, o código ignora (você pode logar/avisar se quiser)

    return total
