import pandas as pd
import numpy as np
from sklearn.neighbors import BallTree

# -----------------------------
# Configuração da distância limite
# -----------------------------
distancia_limite_metros = 250  # pode mudar facilmente
raio_terra_metros = 6371000  # raio médio da Terra em metros
distancia_limite = distancia_limite_metros / raio_terra_metros  # em radianos

# -----------------------------
# Pré-processamento b_sharing
# -----------------------------
----------------------------------------------------------------------------------------------------------------------------------------
# Função para extrair intervalos de altura
# -----------------------------
def extrair_intervalos(texto):
    if pd.isna(texto):
        return []
    
    texto = str(texto).replace(",", ".")  # garante ponto decimal
    intervalos = []
    
    # Regex captura: "0.8 - 3.4", "32 a 38", "21.9 = 23.4", etc.
    matches = re.findall(r'(\d+\.?\d*)\s*[-a=]\s*(\d+\.?\d*)', texto)
    
    for m in matches:
        try:
            minimo = float(m[0])
            maximo = float(m[1])
            if minimo > maximo:  # corrige se vier invertido
                minimo, maximo = maximo, minimo
            intervalos.append((minimo, maximo))
        except:
            continue
    
    return intervalos


# Converte coordenadas para float
b_sharing["Latitude"] = b_sharing["Latitude"].astype(str).str.replace(",", ".").astype(float)
b_sharing["Longitude"] = b_sharing["Longitude"].astype(str).str.replace(",", ".").astype(float)

# Cria coluna "Intervalos" a partir da altura Disponivel
b_sharing["Intervalos"] = b_sharing["altura Disponivel"].apply(extrair_intervalos)

# Converte para radianos (necessário para BallTree com haversine)
coords_b = np.radians(b_sharing[["Latitude", "Longitude"]].to_numpy())


---------------------------------------------------------------------------------------------------------------------------------------


# -----------------------------
# Pré-processamento df_out
# -----------------------------
# Troca vírgula por ponto e converte para float
df_out["Latitude"] = df_out["Latitude"].astype(str).str.replace(",", ".").astype(float)
df_out["Longitude"] = df_out["Longitude"].astype(str).str.replace(",", ".").astype(float)

# Converte para radianos
coords_out = np.radians(df_out[["Latitude", "Longitude"]].to_numpy())

# -----------------------------
# Construção do BallTree
# -----------------------------
tree = BallTree(coords_b, metric="haversine")

# -----------------------------
# Busca de vizinhos dentro do raio
# -----------------------------
detalhes = []

for i, (coord, altura_out) in enumerate(zip(coords_out, df_out["Altura(metros)"])):
    # Encontra todos os índices dentro do raio limite
    indices = tree.query_radius([coord], r=distancia_limite)[0]

    ids_validos = []
    for idx in indices:
        altura_min = b_sharing.iloc[idx]["Altura_min"]
        altura_max = b_sharing.iloc[idx]["Altura_max"]

        # Verifica se altura_out está dentro do intervalo
        if altura_min <= altura_out <= altura_max:
            ids_validos.append(str(b_sharing.iloc[idx]["ID Detentora"]))

    # Monta o texto para a coluna
    if len(ids_validos) == 1:
        detalhes.append(f"É possível fazer colo com o {ids_validos[0]}")
    elif len(ids_validos) > 1:
        detalhes.append(f"É possível fazer colo com as {', '.join(ids_validos)}")
    else:
        detalhes.append(df_out.iloc[i]["Detalhe para Aquisição"])  # mantém valor original

# Atualiza a coluna
df_out["Detalhe para Aquisição"] = detalhes
